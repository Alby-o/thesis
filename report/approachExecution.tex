% !TeX root = ./report.tex
\section{Approach}
The approach was set out by first analysing existing methods of preserving annotations through intermediate representations. These include the:
\begin{itemize}
    \item compCert Verified C Compiler, 
    \item GNU Extension for Extended Inline Assembly, and
    \item Modifying the LLVM compiler to preserve annotations throughout intermediate representations.
\end{itemize}

Each of these approaches will be analysed individually for viability across each of the test cases outlined in section \ref{subsec:testCases}. For approaches that pass all necessary test cases, a further analysis will be conducted into its suitability and development of any necessary tools to assist in the preservation technique, as outlined in sections \ref{subsec:qualityAnalysis} and \ref{subsec:toolDevelopment}. Finally, an analysis on the runtime efficiency of the program will be conducted to assess the success of the annotations with various levels of optimisation. The approach for this analysis is outlined in \ref{subsec:runtimeEfficiencyOptimisation}.

\subsection{Test Cases}
\label{subsec:testCases}
A suite of test C programs (See Appendix \ref{app:testPrograms}) were created to assist in guiding the process of evaluating each approach as a possible means of preserving annotations. Each program has inline comments documenting the annotation that should be preserved and its location within the program. Additionally, each program aims to test a separate element required to perform a static wpif analysis. Namely, these are to preserve the following through to the assembly output:

\begin{enumerate}
    \item comments,
    \item simple and complex variables (e.g. struct elements and volatile global variables),
    \item security policies,
    \item predicates on the initial state, and
    \item loop invariants.
\end{enumerate}

Each test was conducted to assess the viability of each approach of preserving annotations. If the approach cannot preserve all the required annotations described in the aforementioned list, then it is not viable for a wpif analysis and another technique must be explored.

The justification for each of the test files are as follows:

\miniheading{comment.c}
This test case is primarily a stepping stone to testing more complex scenarios. Here we have a generic comment "critical comment" and we are looking to preserve it through to the assembly. As well as preserving the comment itself, the location of the comment within the source code is to be preserved.

\miniheading{variable.c}
The test file \textit{variable.c} builds off \textit{comment.c}, however, we are additionally looking to preserve annotations about local variables within the program. Here multiple variable types are tested:

\begin{itemize}
    \item int,
    \item char,
    \item unsigned int,
    \item short,
    \item long,
    \item float, and
    \item double.
\end{itemize}

With each of these variables their type data is included as an annotation. This test is particularly interesting as with higher levels of optimisation we can observe how the annotations behave when a variable is optimised out.

\miniheading{volatile.c}
This test program looks at how the technique handles volatile variables. A variable declared as volatile tells the program its value could change unexpectedly. This is especially important when dealing with concurrent programs. If the technique cannot handle volatile variables it is unable to be used for a wpif analysis.

\miniheading{loop.c}
This test program tests how the annotator handles loops and loop invariants. It contains security policies, predicates on the initial state and loop invariants.

\miniheading{rooster.c}
The test program, \textit{rooster.c} delves into a more complex program, combining several features of the previous tests. It contains annotations within functions and global variables.

\miniheading{password.c}
This program tests how annotations are preserved within structs, a user-defined data type. Additionally, \textit{password.c} is a more complex program with multiple functions.

\miniheading{deadStoreElimination.c}
Testing dead store elimination is a bit more complex, as it requires comparing the compiled output before and after compiler optimisations are turned on. Here, the test program simulates the program described in section \ref{subsec:compilersSecurity}.

\miniheading{pread.c}
The program \textit{pread.c} is a culmination of all the previous test cases, and is similar to \textit{loop.c}, however, the global variables within it are volatile. It requires all the necessary components for a wpif analysis.

\subsection{Quality Analysis}
\label{subsec:qualityAnalysis}
Although a method of preserving c annotations may be able to successfully pass all the test cases, it is important to avoid modifying the compiled assembly or binary output. The reason for performing a static analysis on the compiled output is due to compiler optimisations 

- compiler optimisation

\subsection{Tool Development}
\label{subsec:toolDevelopment}

\subsection{Runtime Efficiency and Optimisation}
\label{subsec:runtimeEfficiencyOptimisation}



\clearpage
\section{Execution}
Testing began with the CompCert compiler and assembly annotation tools provided within, outlined in section \ref{subsec:compCert}. It was found that the CompCert compiler could not handle all cases necessary for the wpif analysis, specifically volatile variables. As a result, the testing moved on to other techniques. Following this, the GNU C extension for inline assembly was explored as a possibility to preserve annotations in C in section \ref{subsec:inlineAssembly}. This technique prevailed and was found to be excellent in handling assembly annotations by injecting comments in to the compiled assembly output. This technique was enhanced by developing a python program to inject inline assembly into the source C files to allow for enhanced analysis and furthermore avoids restricting the program to GNU extension supporting compilers. As a result of the success, modifying the compiler was not explored due to success documented in other research such as the work conducted by Vu et al. \cite{vu2020secure}. This allowed for further development and improvement of the inline assembly method.

\subsection{CompCert Annotations}
\label{subsec:compCert}
CompCert is unfortunately not a free tool, however, for research purposes it can be used freely. The specifications of the CompCert install can be seen in Table \ref{tab:compcertInstall}. 

\begin{table}
    \begin{center}
        \begin{tabularx}{\linewidth} { 
            | >{\hsize=.7\hsize\linewidth=\hsize}X 
            | >{\hsize=1.3\hsize\linewidth=\hsize}X  | }
            \hline
            OS Name & Ubuntu 20.04.2 LTS \\
            \hline
            OS Type & 64-bit \\
            \hline
            Processor & Intel® Core™ i7-6700K CPU @ 4.00GHz × 8 \\
            \hline
            \raggedright
            CompCert Version & The CompCert C verified compiler, version 3.7 \\
            \hline
        \end{tabularx}
    \end{center}
    \caption{CompCert install specifications}
    \label{tab:compcertInstall}
\end{table}

Testing was initially conducted using the \textit{comment.c} test file. The goal is to propagate the comment down to assembly where it can be used and interpreted. To do so, the comment in the source code needs to be replaced with a call to generate an annotation in the compiled assembly. Fortunately, with the compCert compiler, this functionality is builtin. This assembly annotation is created through the use of the \texttt{\_\_builtin\_annot} function described in \ref{subsec:relatedWorkCompCert}. The following builtin annotation was placed in line 2, within the main function in \textit{comment.c}.

\begin{lstlisting}[language=C]
__builtin_ais_annot("%here Critical Comment");
\end{lstlisting}

Within this annotation, \code{\%here} is used to represent the location within the program. If the location is not important, \code{\%here} can be omitted. The comment, \code{"Critical Comment"}, has been included to represent some kind of critical comment that is required to conduct a static analysis on the output. The full compiled output can be seen in Appendix \ref{app:compCertOutput}.

\subsubsection{CompCert Results}

\subsection{Inline Assembly}

\subsection{LLVM Compiler Modification}
the final technique of modifying the LLVM compiler was not experimented on. This was primarily due to two reasons. To begin with, the primary objective of this thesis is to explore techniques that do not modify the compiler, and instead work alongside the functionality of the compiler to preserve annotations. It is well known and documented that modifying the compiler to preserve annotations is possible and successful, as in the case of Vu et al. \cite{vu2020secure} Additionally, earlier success through the technique of using inline assembly allowed for more time to be allocated to exploring and improving this technique, as will be seen in section \ref{subsec:inlineAssembly}.

\label{subsec:inlineAssembly}
% // error: access to volatile variable 'z' for parameter '%e1' is not supported in ais annotations
% // error: access to volatile variable 'x' for parameter '%e1' is not supported in ais annotations
% // error: access to volatile variable 'z' for parameter '%e2' is not supported in ais annotations

% TODO: 
% - Inline assembly
% - Source Code documentation
% - Speed Comparison Normal, CompCert, Inline Ass
