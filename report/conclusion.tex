\chapter{Conclusions and Future Work}
In conclusion, the analysed methods of preserving annotations in C have yielded some interesting results. To begin with, CompCert AIS annotations were experimented with to analyse their effectiveness for preserving annotations. The AIS annotations were excellent as they were quite robust and did not interfere with any compiler optimisations. However, this did come with a downside. The method did not support volatile variables. Unfortunately, this excludes it from possibly being used as an annotation technique for concurrent programs. As concurrent programs rely on volatile variables, being unable to annotate the location of these variables excludes it as a possibility. Additionally, however, not so importantly, it does not support floating point numbers either. For programmers wishing to annotate their code that do not require annotations for volatile or floating point numbers, CompCert AIS annotations is an excellent choice. However, one must also consider the downside associated with being locked-in the the CompCert compiler.  

For all three methods analysed of preserving annotations, they were treated as a call to an external function. Thus, any annotations placed within dead code was optimised out and removed with compiler optimisations turned on, and no annotations could be placed at the top-level of a program alongside a variable. As such, this has been left for future work. Additionally, it was a consistent theme across all methods for variable annotations to lose meaning when variables have been optimised away. In all three cases, when the variable has been optimised out, references to the variable are replaced with its value instead. This is an interesting situation, as although we want all compiler optimisations to run, losing a variable does increase the difficultly of performing a security analysis. 

The CompCert builtin annotations were also explored as a method of preserving annotations. It performs similarly to that of the CompCert AIS annotations, however, is not robust like the AIS annotations were. Although it does support volatile variables and floating point numbers, it also adds additional assembly instructions to the compiled output. These additional instructions are likely added as compiler optimisations are sometimes unable to be performed due to the annotations. Unfortunately, these additional assembly instructions do slow the program and thus are an unfortunate side-effect of the builtin CompCert annotations. 

Finally, the inline assembly method of annotating assembly showed a lot of promise. The annotations worked for all necessary components of a static analysis of a concurrent program, however, they did add additional move statements. These move statements could be backtraced to find the true location of the variable, however, they slowed the program linearly with the number of annotations added. Thus, to circumvent this issue, a program was successfully developed to assist in the annotation process without preventing compiler optimisations. The program transpiles the source code and extracts annotations compiled into the assembly. However, it does not properly locate variables from the additional move statements. This is because doing so would require parsing the assembly, which is machine dependent. Thus this has been left for future work.

\section{Performance Review}
From the initial plan set out in this thesis's proposal, the stated schedule was not followed closely. The initial plan had 5 separate stages of investigation, evaluation, development, testing and formalisation, with 30 hours, 10 hours, 100 hours, 30 hours and 30 hours allocated respectively. Notably, in this initial plan much of the allocated time was given to developing some kind of tool and testing it, however, far less time was spent doing so than originally expected. This was primarily because the final technique of modifying the compiler was not explored. Earlier successes with inline assembly annotations allowed for more time to be dedicated to the annotation technique.

One major aspect of the disproportion of time estimated was due to the underestimation of the time it would take to evaluate and understand the results and findings of the assembly. As I have not worked with assembly in the part, a large portion of my time was spent learning to understand and follow the results found. 

Additionally, the time required to formalise the results was vastly underestimated. 30 hours of time was allocated, however, much more time was spent writing this paper. This is likely because I have not formalised the results of such a large amount of work in the past. Most of the writing was left until the final two weeks. As a result, a large amount of time was spent returning to work completed in the previous semester and re-evaluating the results to include in this report.

In regards to the goals of the thesis, they were largely met. Several methods were discovered for preserving annotations in assembly for a static analysis of concurrent programs. However, modifying the compiler was not explored as much as I had originally hoped. However, this is due to the large successes formulated from analysing the inline assembly method. There is still work to be completed to extract the location of variables from annotations using the inline assembly method, however, the information is successfully preserved to assembly. 

Developing a methodology and approach for assessing each compilation technique drastically helped achieve the goals of this thesis. Before developing a testing and analysis plan, the work conducted was unsatisfactory and had no clear objective or path forwards. However, once a plan and approach was in place the thesis work conducted had a clear goal of what was to be preserved in annotations and how to analyse and assess the results.
