\chapter{Conclusions and Future Work}
In conclusion, the analysed methods of preserving annotations in C have yielded some interesting results. To begin with, CompCert AIS annotations were experimented with to analyse their effectiveness for preserving annotations. The AIS annotations were excellent as they were quite robust and did not interfere with any compiler optimisations. However, this did come with a downside. The method did not support volatile variables. Unfortunately, this excludes it from possibly being used as an annotation technique for concurrent programs. As concurrent programs rely on volatile variables, being unable to annotate the location of these variables excludes it as a possibility. Additionally, however, not so importantly, it does not support floating point numbers either. For programmers wishing to annotate their code that do not require annotations for volatile or floating point numbers, CompCert AIS annotations is an excellent choice. However, one must also consider the downside associated with being locked-in the the CompCert compiler.  

For all three methods analysed of preserving annotations, they were treated as a call to an external function. Thus, any annotations placed within dead code was optimised out and removed with compiler optimisations turned on, and no annotations could be placed at the top-level of a program alongside a variable. As such, this has been left for future work. Additionally, it was a consistent theme across all methods for variable annotations to lose meaning when variables have been optimised away. In all three cases, when the variable has been optimised out, references to the variable are replaced with its value instead. This is an interesting situation, as although we want all compiler optimisations to run, losing a variable does increase the difficultly of performing a security analysis. 

The CompCert builtin annotations were also explored as a method of preserving annotations. It performs similarly to that of the CompCert AIS annotations, however, is not robust like the AIS annotations were. Although it does support volatile variables and floating point numbers, it also adds additional assembly instructions to the compiled output. These additional instructions are likely added as compiler optimisations are sometimes unable to be performed due to the annotations. Unfortunately, these additional assembly instructions do slow the program and thus are an unfortunate side-effect of the builtin CompCert annotations. 

Finally, the inline assembly method of annotating assembly showed a lot of promise. The annotations worked for all necessary components of a static analysis of a concurrent program, however, they did add additional move statements. These move statements could be backtraced to find the true location of the variable, however, they slowed the program linearly with the number of annotations added. Thus, to circumvent this issue, a program was successfully developed to assist in the annotation process without preventing compiler optimisations. The program transpiles the source code and extracts annotations compiled into the assembly. However, it does not properly locate variables from the additional move statements. This is because doing so would require parsing the assembly, which is machine dependent. Thus this has been left for future work.

\section{Performance Review}
From the initial plan set out in this thesis's proposal, the stated schedule was not followed closely. The initial plan had 5 separate stages of investigation, evaluation, development, testing and formalisation, with a time estimate associated with each. In this initial plan, much of the allocated time was given to developing some kind of tool and testing it, however, far less time was spent developing a tool than originally expected. This was primarily because the final technique of modifying the compiler was not explored. This was primarily because earlier successes with inline assembly allowed for more time to be dedicated to the technique. 

% Goals were almost fully met - more work to be done on tool developed, additionally further research into compiler modification possible. 




% The results from the work should be analysed in a fashion that highlights your comprehension and shows insight into the significance of the results. 

% The thesis should have a critical review of your performance against the stated plan, including the stated goals and schedule. 

% The thesis should conclude with a clear concise summary of the outcomes of the thesis (relating to your initial definitions and  put  in  context  of  the  literature)  and  recommendations  of  how  the  work  might  be continued or improved